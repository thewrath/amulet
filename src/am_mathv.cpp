// This file is generated by tools/gen_mathv.lua

#include "amulet.h"
#include "am_mathv_helper.inc"

static int add_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.add");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.add", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = ADD_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = ADD_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = ADD_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = ADD_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = ADD_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = ADD_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = ADD_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.add", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ADD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = ADD_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.add");
}

int am_mathv_add(lua_State *L) {
    return add_impl(L, NULL);
}

static int am_mathv_add_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return add_impl(L, view);
}

static int sub_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.sub");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.sub", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = SUB_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = SUB_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = SUB_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = SUB_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = SUB_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = SUB_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = SUB_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.sub", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = SUB_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = SUB_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.sub");
}

int am_mathv_sub(lua_State *L) {
    return sub_impl(L, NULL);
}

static int am_mathv_sub_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return sub_impl(L, view);
}

static int vec_mul_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.vec_mul");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.vec_mul", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = MUL_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = MUL_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = MUL_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = MUL_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = MUL_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = MUL_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = MUL_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.vec_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = MUL_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = MUL_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec_mul");
}

static int am_mathv_vec_mul(lua_State *L) {
    return vec_mul_impl(L, NULL);
}

static int am_mathv_vec_mul_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec_mul_impl(L, view);
}

static int div_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.div");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.div", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = DIV_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = DIV_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = DIV_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = DIV_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = DIV_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = DIV_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = DIV_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.div", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = DIV_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = DIV_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.div");
}

int am_mathv_div(lua_State *L) {
    return div_impl(L, NULL);
}

static int am_mathv_div_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return div_impl(L, view);
}

static int mod_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.mod");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.mod", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = F32MOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = F32MOD_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = F64MOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = F64MOD_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = IMOD_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = IMOD_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = IMOD_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = IMOD_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = IMOD_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.mod", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = IMOD_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = IMOD_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mod");
}

int am_mathv_mod(lua_State *L) {
    return mod_impl(L, NULL);
}

static int am_mathv_mod_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mod_impl(L, view);
}

static int pow_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.pow");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.pow", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.pow", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = powf(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = powf(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.pow", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = pow(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = pow(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.pow");
}

int am_mathv_pow(lua_State *L) {
    return pow_impl(L, NULL);
}

static int am_mathv_pow_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return pow_impl(L, view);
}

static int unm_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    nargs = am_min(nargs, 1);        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.unm", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = UNM_OP(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = UNM_OP(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int8_t *out_arr = (int8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int8_t*)output_data)[c] = UNM_OP(((int8_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = UNM_OP(((uint8_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int16_t *out_arr = (int16_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int16_t*)output_data)[c] = UNM_OP(((int16_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint16_t *out_arr = (uint16_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint16_t*)output_data)[c] = UNM_OP(((uint16_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_I32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            int32_t *out_arr = (int32_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((int32_t*)output_data)[c] = UNM_OP(((int32_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.unm", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint32_t *out_arr = (uint32_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = UNM_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint32_t*)output_data)[c] = UNM_OP(((uint32_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.unm");
}

int am_mathv_unm(lua_State *L) {
    return unm_impl(L, NULL);
}

static int am_mathv_unm_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return unm_impl(L, view);
}

static int abs_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.abs");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.abs", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.abs", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = fabsf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = fabsf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.abs", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = fabs(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = fabs(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.abs");
}

static int am_mathv_abs(lua_State *L) {
    return abs_impl(L, NULL);
}

static int am_mathv_abs_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return abs_impl(L, view);
}

static int acos_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.acos");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.acos", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.acos", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = acosf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = acosf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.acos", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = acos(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = acos(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.acos");
}

static int am_mathv_acos(lua_State *L) {
    return acos_impl(L, NULL);
}

static int am_mathv_acos_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return acos_impl(L, view);
}

static int asin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.asin");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.asin", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.asin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = asinf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = asinf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.asin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = asin(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = asin(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.asin");
}

static int am_mathv_asin(lua_State *L) {
    return asin_impl(L, NULL);
}

static int am_mathv_asin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return asin_impl(L, view);
}

static int atan_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.atan");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.atan", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.atan", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = atanf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = atanf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.atan", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = atan(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = atan(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.atan");
}

static int am_mathv_atan(lua_State *L) {
    return atan_impl(L, NULL);
}

static int am_mathv_atan_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return atan_impl(L, view);
}

static int atan2_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.atan2");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.atan2", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.atan2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = atan2f(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = atan2f(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.atan2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = atan2(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = atan2(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.atan2");
}

static int am_mathv_atan2(lua_State *L) {
    return atan2_impl(L, NULL);
}

static int am_mathv_atan2_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return atan2_impl(L, view);
}

static int ceil_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.ceil");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.ceil", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.ceil", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ceilf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = ceilf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.ceil", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = ceil(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = ceil(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.ceil");
}

static int am_mathv_ceil(lua_State *L) {
    return ceil_impl(L, NULL);
}

static int am_mathv_ceil_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return ceil_impl(L, view);
}

static int clamp_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 3) return luaL_error(L, "too many arguments for mathv.clamp");        uint8_t arg_singleton_scratch[3][16*8];
    uint8_t *arg_singleton_bufs[3];
    for (unsigned int i = 0; i < 3; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[3];
    unsigned int arg_stride[3];
    unsigned int arg_count[3];
    int arg_type[3];
    am_buffer_view_type arg_view_type[3];
    unsigned int arg_components[3];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.clamp", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 3  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.clamp", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            float *arg3_arr = (float*)arg_data[2];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_clamp(arg1_arr[i], arg2_arr[i], arg3_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            uint8_t *arg3_ptr = arg_data[2];
            int arg3_stride = arg_stride[2];
            int mask3 = arg_components[2] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_clamp(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2], ((float*)arg3_ptr)[c & mask3]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                arg3_ptr += arg3_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 3  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.clamp", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            double *arg3_arr = (double*)arg_data[2];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_clamp(arg1_arr[i], arg2_arr[i], arg3_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            uint8_t *arg3_ptr = arg_data[2];
            int arg3_stride = arg_stride[2];
            int mask3 = arg_components[2] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_clamp(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2], ((double*)arg3_ptr)[c & mask3]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                arg3_ptr += arg3_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.clamp");
}

static int am_mathv_clamp(lua_State *L) {
    return clamp_impl(L, NULL);
}

static int am_mathv_clamp_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return clamp_impl(L, view);
}

static int cos_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.cos");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.cos", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.cos", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = cosf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = cosf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.cos", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = cos(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = cos(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.cos");
}

static int am_mathv_cos(lua_State *L) {
    return cos_impl(L, NULL);
}

static int am_mathv_cos_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return cos_impl(L, view);
}

static int floor_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.floor");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.floor", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.floor", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = floorf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = floorf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.floor", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = floor(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = floor(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.floor");
}

static int am_mathv_floor(lua_State *L) {
    return floor_impl(L, NULL);
}

static int am_mathv_floor_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return floor_impl(L, view);
}

static int fract_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.fract");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.fract", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.fract", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = glm::fract(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = glm::fract(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.fract", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = glm::fract(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = glm::fract(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.fract");
}

static int am_mathv_fract(lua_State *L) {
    return fract_impl(L, NULL);
}

static int am_mathv_fract_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return fract_impl(L, view);
}

static int log_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.log");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.log", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.log", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = logf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = logf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.log", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = log(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = log(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.log");
}

static int am_mathv_log(lua_State *L) {
    return log_impl(L, NULL);
}

static int am_mathv_log_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return log_impl(L, view);
}

static int max_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.max");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.max", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.max", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_max(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_max(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.max", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_max(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_max(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.max");
}

static int am_mathv_max(lua_State *L) {
    return max_impl(L, NULL);
}

static int am_mathv_max_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return max_impl(L, view);
}

static int min_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.min");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.min", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.min", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_min(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_min(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.min", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_min(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_min(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.min");
}

static int am_mathv_min(lua_State *L) {
    return min_impl(L, NULL);
}

static int am_mathv_min_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return min_impl(L, view);
}

static int mix_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 3) return luaL_error(L, "too many arguments for mathv.mix");        uint8_t arg_singleton_scratch[3][16*8];
    uint8_t *arg_singleton_bufs[3];
    for (unsigned int i = 0; i < 3; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[3];
    unsigned int arg_stride[3];
    unsigned int arg_count[3];
    int arg_type[3];
    am_buffer_view_type arg_view_type[3];
    unsigned int arg_components[3];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.mix", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 3  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mix", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            float *arg3_arr = (float*)arg_data[2];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = glm::mix(arg1_arr[i], arg2_arr[i], arg3_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            uint8_t *arg3_ptr = arg_data[2];
            int arg3_stride = arg_stride[2];
            int mask3 = arg_components[2] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = glm::mix(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2], ((float*)arg3_ptr)[c & mask3]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                arg3_ptr += arg3_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 3  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mix", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            double *arg3_arr = (double*)arg_data[2];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = glm::mix(arg1_arr[i], arg2_arr[i], arg3_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            uint8_t *arg3_ptr = arg_data[2];
            int arg3_stride = arg_stride[2];
            int mask3 = arg_components[2] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = glm::mix(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2], ((double*)arg3_ptr)[c & mask3]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                arg3_ptr += arg3_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mix");
}

static int am_mathv_mix(lua_State *L) {
    return mix_impl(L, NULL);
}

static int am_mathv_mix_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mix_impl(L, view);
}

static int sign_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.sign");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.sign", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.sign", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_sign(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = am_sign(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.sign", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = am_sign(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = am_sign(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.sign");
}

static int am_mathv_sign(lua_State *L) {
    return sign_impl(L, NULL);
}

static int am_mathv_sign_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return sign_impl(L, view);
}

static int sin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.sin");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.sin", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.sin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = sinf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = sinf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.sin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = sin(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = sin(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.sin");
}

static int am_mathv_sin(lua_State *L) {
    return sin_impl(L, NULL);
}

static int am_mathv_sin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return sin_impl(L, view);
}

static int tan_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.tan");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.tan", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.tan", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            float *out_arr = (float*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = tanf(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((float*)output_data)[c] = tanf(((float*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.tan", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            double *out_arr = (double*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = tan(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((double*)output_data)[c] = tan(((double*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.tan");
}

static int am_mathv_tan(lua_State *L) {
    return tan_impl(L, NULL);
}

static int am_mathv_tan_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return tan_impl(L, view);
}

static int lt_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.lt");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.lt", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.lt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LT_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.lt");
}

static int am_mathv_lt(lua_State *L) {
    return lt_impl(L, NULL);
}

static int am_mathv_lt_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return lt_impl(L, view);
}

static int lte_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.lte");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.lte", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.lte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = LTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = LTE_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.lte");
}

static int am_mathv_lte(lua_State *L) {
    return lte_impl(L, NULL);
}

static int am_mathv_lte_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return lte_impl(L, view);
}

static int gt_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.gt");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.gt", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.gt", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GT_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GT_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.gt");
}

static int am_mathv_gt(lua_State *L) {
    return gt_impl(L, NULL);
}

static int am_mathv_gt_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return gt_impl(L, view);
}

static int gte_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.gte");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.gte", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            float *arg1_arr = (float*)arg_data[0];
            float *arg2_arr = (float*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((float*)arg1_ptr)[c & mask1], ((float*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            double *arg1_arr = (double*)arg_data[0];
            double *arg2_arr = (double*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((double*)arg1_ptr)[c & mask1], ((double*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I8;
        arg_view_type[1] = AM_VIEW_TYPE_I8;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int8_t *arg1_arr = (int8_t*)arg_data[0];
            int8_t *arg2_arr = (int8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((int8_t*)arg1_ptr)[c & mask1], ((int8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U16;
        arg_view_type[1] = AM_VIEW_TYPE_U16;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint16_t *arg1_arr = (uint16_t*)arg_data[0];
            uint16_t *arg2_arr = (uint16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((uint16_t*)arg1_ptr)[c & mask1], ((uint16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I16) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I16) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I16;
        arg_view_type[1] = AM_VIEW_TYPE_I16;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int16_t *arg1_arr = (int16_t*)arg_data[0];
            int16_t *arg2_arr = (int16_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((int16_t*)arg1_ptr)[c & mask1], ((int16_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U32;
        arg_view_type[1] = AM_VIEW_TYPE_U32;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint32_t *arg1_arr = (uint32_t*)arg_data[0];
            uint32_t *arg2_arr = (uint32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((uint32_t*)arg1_ptr)[c & mask1], ((uint32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_I32) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_I32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_I32;
        arg_view_type[1] = AM_VIEW_TYPE_I32;
        setup_non_view_args(L, "mathv.gte", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            int32_t *arg1_arr = (int32_t*)arg_data[0];
            int32_t *arg2_arr = (int32_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = GTE_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = GTE_OP(((int32_t*)arg1_ptr)[c & mask1], ((int32_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.gte");
}

static int am_mathv_gte(lua_State *L) {
    return gte_impl(L, NULL);
}

static int am_mathv_gte_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return gte_impl(L, view);
}

static int and__impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.and_");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.and_", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.and_", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = AND_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = AND_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.and_");
}

static int am_mathv_and_(lua_State *L) {
    return and__impl(L, NULL);
}

static int am_mathv_and__into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return and__impl(L, view);
}

static int or__impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.or_");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.or_", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 2  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view) && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_U8) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        arg_view_type[1] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.or_", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            uint8_t *arg2_arr = (uint8_t*)arg_data[1];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = OR_OP(arg1_arr[i], arg2_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            uint8_t *arg2_ptr = arg_data[1];
            int arg2_stride = arg_stride[1];
            int mask2 = arg_components[1] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = OR_OP(((uint8_t*)arg1_ptr)[c & mask1], ((uint8_t*)arg2_ptr)[c & mask2]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                arg2_ptr += arg2_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.or_");
}

static int am_mathv_or_(lua_State *L) {
    return or__impl(L, NULL);
}

static int am_mathv_or__into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return or__impl(L, view);
}

static int not__impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.not_");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool args_are_dense;
    bool output_is_dense;
    component_wise_setup(L, "mathv.not_", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count, &output_components, &args_are_dense);
    if (nargs == 1  && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_U8) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_U8;
        setup_non_view_args(L, "mathv.not_", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_U8;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        if (output_is_dense && args_are_dense) {
            uint8_t *out_arr = (uint8_t*)output_data;
            uint8_t *arg1_arr = (uint8_t*)arg_data[0];
            
            unsigned int n = output_count * output_components;
            for (unsigned int i = 0; i < n; ++i) {
                out_arr[i] = NOT_OP(arg1_arr[i]);
            }
        } else {
            uint8_t *arg1_ptr = arg_data[0];
            int arg1_stride = arg_stride[0];
            int mask1 = arg_components[0] == 1 ? 0 : 0xFFFF;
            
            for (unsigned int i = 0; i < output_count; ++i) {
                for (unsigned int c = 0; c < output_components; ++c) {
                    ((uint8_t*)output_data)[c] = NOT_OP(((uint8_t*)arg1_ptr)[c & mask1]);
                }
                output_data += output_stride;
                arg1_ptr += arg1_stride;
                
            }
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.not_");
}

static int am_mathv_not_(lua_State *L) {
    return not__impl(L, NULL);
}

static int am_mathv_not__into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return not__impl(L, view);
}

static int vec2_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.vec2");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.vec2", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec2*)output_data) = glm::vec2(*((float*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec2*)output_data) = glm::vec2(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec2*)output_data) = glm::dvec2(*((double*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec2", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec2*)output_data) = glm::dvec2(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec2");
}

static int am_mathv_vec2(lua_State *L) {
    return vec2_impl(L, NULL);
}

static int am_mathv_vec2_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec2_impl(L, view);
}

static int vec3_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 3) return luaL_error(L, "too many arguments for mathv.vec3");        uint8_t arg_singleton_scratch[3][16*8];
    uint8_t *arg_singleton_bufs[3];
    for (unsigned int i = 0; i < 3; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[3];
    unsigned int arg_stride[3];
    unsigned int arg_count[3];
    int arg_type[3];
    am_buffer_view_type arg_view_type[3];
    unsigned int arg_components[3];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.vec3", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::vec3(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::vec3(*((glm::vec2*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::vec3(*((float*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::vec3(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::dvec3(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::dvec3(*((glm::dvec2*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::dvec3(*((double*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::dvec3(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec3");
}

static int am_mathv_vec3(lua_State *L) {
    return vec3_impl(L, NULL);
}

static int am_mathv_vec3_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec3_impl(L, view);
}

static int vec4_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 4) return luaL_error(L, "too many arguments for mathv.vec4");        uint8_t arg_singleton_scratch[4][16*8];
    uint8_t *arg_singleton_bufs[4];
    for (unsigned int i = 0; i < 4; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[4];
    unsigned int arg_stride[4];
    unsigned int arg_count[4];
    int arg_type[4];
    am_buffer_view_type arg_view_type[4];
    unsigned int arg_components[4];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.vec4", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 4  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        arg_view_type[3] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((glm::vec3*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((float*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 2 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((glm::vec2*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((float*)in_ptr_1), *((glm::vec2*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((glm::vec2*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::vec4(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        arg_view_type[3] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((glm::dvec3*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((double*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 2 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((glm::dvec2*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((double*)in_ptr_1), *((glm::dvec2*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((glm::dvec2*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.vec4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::dvec4(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.vec4");
}

static int am_mathv_vec4(lua_State *L) {
    return vec4_impl(L, NULL);
}

static int am_mathv_vec4_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return vec4_impl(L, view);
}

static int mat3_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 9) return luaL_error(L, "too many arguments for mathv.mat3");        uint8_t arg_singleton_scratch[9][16*8];
    uint8_t *arg_singleton_bufs[9];
    for (unsigned int i = 0; i < 9; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[9];
    unsigned int arg_stride[9];
    unsigned int arg_count[9];
    int arg_type[9];
    am_buffer_view_type arg_view_type[9];
    unsigned int arg_components[9];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.mat3", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 9  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F32) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F32) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F32) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F32) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F32) || arg_type[8] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        arg_view_type[3] = AM_VIEW_TYPE_F32;
        arg_view_type[4] = AM_VIEW_TYPE_F32;
        arg_view_type[5] = AM_VIEW_TYPE_F32;
        arg_view_type[6] = AM_VIEW_TYPE_F32;
        arg_view_type[7] = AM_VIEW_TYPE_F32;
        arg_view_type[8] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = glm::mat3(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4), *((float*)in_ptr_5), *((float*)in_ptr_6), *((float*)in_ptr_7), *((float*)in_ptr_8), *((float*)in_ptr_9));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 3 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = glm::mat3(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2), *((glm::vec3*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 9  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F64) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F64) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F64) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F64) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F64) || arg_type[8] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        arg_view_type[3] = AM_VIEW_TYPE_F64;
        arg_view_type[4] = AM_VIEW_TYPE_F64;
        arg_view_type[5] = AM_VIEW_TYPE_F64;
        arg_view_type[6] = AM_VIEW_TYPE_F64;
        arg_view_type[7] = AM_VIEW_TYPE_F64;
        arg_view_type[8] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = glm::dmat3(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4), *((double*)in_ptr_5), *((double*)in_ptr_6), *((double*)in_ptr_7), *((double*)in_ptr_8), *((double*)in_ptr_9));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 3  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 3 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat3", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = glm::dmat3(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2), *((glm::dvec3*)in_ptr_3));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat3");
}

static int am_mathv_mat3(lua_State *L) {
    return mat3_impl(L, NULL);
}

static int am_mathv_mat3_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat3_impl(L, view);
}

static int mat4_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 16) return luaL_error(L, "too many arguments for mathv.mat4");        uint8_t arg_singleton_scratch[16][16*8];
    uint8_t *arg_singleton_bufs[16];
    for (unsigned int i = 0; i < 16; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[16];
    unsigned int arg_stride[16];
    unsigned int arg_count[16];
    int arg_type[16];
    am_buffer_view_type arg_view_type[16];
    unsigned int arg_components[16];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.mat4", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 16  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F32) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F32) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F32) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F32) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F32) || arg_type[8] != MT_am_buffer_view) && arg_components[9] == 1 && ((arg_type[9] == MT_am_buffer_view && arg_view_type[9] == AM_VIEW_TYPE_F32) || arg_type[9] != MT_am_buffer_view) && arg_components[10] == 1 && ((arg_type[10] == MT_am_buffer_view && arg_view_type[10] == AM_VIEW_TYPE_F32) || arg_type[10] != MT_am_buffer_view) && arg_components[11] == 1 && ((arg_type[11] == MT_am_buffer_view && arg_view_type[11] == AM_VIEW_TYPE_F32) || arg_type[11] != MT_am_buffer_view) && arg_components[12] == 1 && ((arg_type[12] == MT_am_buffer_view && arg_view_type[12] == AM_VIEW_TYPE_F32) || arg_type[12] != MT_am_buffer_view) && arg_components[13] == 1 && ((arg_type[13] == MT_am_buffer_view && arg_view_type[13] == AM_VIEW_TYPE_F32) || arg_type[13] != MT_am_buffer_view) && arg_components[14] == 1 && ((arg_type[14] == MT_am_buffer_view && arg_view_type[14] == AM_VIEW_TYPE_F32) || arg_type[14] != MT_am_buffer_view) && arg_components[15] == 1 && ((arg_type[15] == MT_am_buffer_view && arg_view_type[15] == AM_VIEW_TYPE_F32) || arg_type[15] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        arg_view_type[3] = AM_VIEW_TYPE_F32;
        arg_view_type[4] = AM_VIEW_TYPE_F32;
        arg_view_type[5] = AM_VIEW_TYPE_F32;
        arg_view_type[6] = AM_VIEW_TYPE_F32;
        arg_view_type[7] = AM_VIEW_TYPE_F32;
        arg_view_type[8] = AM_VIEW_TYPE_F32;
        arg_view_type[9] = AM_VIEW_TYPE_F32;
        arg_view_type[10] = AM_VIEW_TYPE_F32;
        arg_view_type[11] = AM_VIEW_TYPE_F32;
        arg_view_type[12] = AM_VIEW_TYPE_F32;
        arg_view_type[13] = AM_VIEW_TYPE_F32;
        arg_view_type[14] = AM_VIEW_TYPE_F32;
        arg_view_type[15] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        int in_stride_10 = arg_stride[9];
        uint8_t *in_ptr_10 = &arg_data[9][0];
        int in_stride_11 = arg_stride[10];
        uint8_t *in_ptr_11 = &arg_data[10][0];
        int in_stride_12 = arg_stride[11];
        uint8_t *in_ptr_12 = &arg_data[11][0];
        int in_stride_13 = arg_stride[12];
        uint8_t *in_ptr_13 = &arg_data[12][0];
        int in_stride_14 = arg_stride[13];
        uint8_t *in_ptr_14 = &arg_data[13][0];
        int in_stride_15 = arg_stride[14];
        uint8_t *in_ptr_15 = &arg_data[14][0];
        int in_stride_16 = arg_stride[15];
        uint8_t *in_ptr_16 = &arg_data[15][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = glm::mat4(*((float*)in_ptr_1), *((float*)in_ptr_2), *((float*)in_ptr_3), *((float*)in_ptr_4), *((float*)in_ptr_5), *((float*)in_ptr_6), *((float*)in_ptr_7), *((float*)in_ptr_8), *((float*)in_ptr_9), *((float*)in_ptr_10), *((float*)in_ptr_11), *((float*)in_ptr_12), *((float*)in_ptr_13), *((float*)in_ptr_14), *((float*)in_ptr_15), *((float*)in_ptr_16));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            in_ptr_10 += in_stride_10;
            in_ptr_11 += in_stride_11;
            in_ptr_12 += in_stride_12;
            in_ptr_13 += in_stride_13;
            in_ptr_14 += in_stride_14;
            in_ptr_15 += in_stride_15;
            in_ptr_16 += in_stride_16;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 4 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F32) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 4 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F32) || arg_type[3] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        arg_view_type[2] = AM_VIEW_TYPE_F32;
        arg_view_type[3] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = glm::mat4(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2), *((glm::vec4*)in_ptr_3), *((glm::vec4*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 16  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 1 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 1 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view) && arg_components[4] == 1 && ((arg_type[4] == MT_am_buffer_view && arg_view_type[4] == AM_VIEW_TYPE_F64) || arg_type[4] != MT_am_buffer_view) && arg_components[5] == 1 && ((arg_type[5] == MT_am_buffer_view && arg_view_type[5] == AM_VIEW_TYPE_F64) || arg_type[5] != MT_am_buffer_view) && arg_components[6] == 1 && ((arg_type[6] == MT_am_buffer_view && arg_view_type[6] == AM_VIEW_TYPE_F64) || arg_type[6] != MT_am_buffer_view) && arg_components[7] == 1 && ((arg_type[7] == MT_am_buffer_view && arg_view_type[7] == AM_VIEW_TYPE_F64) || arg_type[7] != MT_am_buffer_view) && arg_components[8] == 1 && ((arg_type[8] == MT_am_buffer_view && arg_view_type[8] == AM_VIEW_TYPE_F64) || arg_type[8] != MT_am_buffer_view) && arg_components[9] == 1 && ((arg_type[9] == MT_am_buffer_view && arg_view_type[9] == AM_VIEW_TYPE_F64) || arg_type[9] != MT_am_buffer_view) && arg_components[10] == 1 && ((arg_type[10] == MT_am_buffer_view && arg_view_type[10] == AM_VIEW_TYPE_F64) || arg_type[10] != MT_am_buffer_view) && arg_components[11] == 1 && ((arg_type[11] == MT_am_buffer_view && arg_view_type[11] == AM_VIEW_TYPE_F64) || arg_type[11] != MT_am_buffer_view) && arg_components[12] == 1 && ((arg_type[12] == MT_am_buffer_view && arg_view_type[12] == AM_VIEW_TYPE_F64) || arg_type[12] != MT_am_buffer_view) && arg_components[13] == 1 && ((arg_type[13] == MT_am_buffer_view && arg_view_type[13] == AM_VIEW_TYPE_F64) || arg_type[13] != MT_am_buffer_view) && arg_components[14] == 1 && ((arg_type[14] == MT_am_buffer_view && arg_view_type[14] == AM_VIEW_TYPE_F64) || arg_type[14] != MT_am_buffer_view) && arg_components[15] == 1 && ((arg_type[15] == MT_am_buffer_view && arg_view_type[15] == AM_VIEW_TYPE_F64) || arg_type[15] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        arg_view_type[3] = AM_VIEW_TYPE_F64;
        arg_view_type[4] = AM_VIEW_TYPE_F64;
        arg_view_type[5] = AM_VIEW_TYPE_F64;
        arg_view_type[6] = AM_VIEW_TYPE_F64;
        arg_view_type[7] = AM_VIEW_TYPE_F64;
        arg_view_type[8] = AM_VIEW_TYPE_F64;
        arg_view_type[9] = AM_VIEW_TYPE_F64;
        arg_view_type[10] = AM_VIEW_TYPE_F64;
        arg_view_type[11] = AM_VIEW_TYPE_F64;
        arg_view_type[12] = AM_VIEW_TYPE_F64;
        arg_view_type[13] = AM_VIEW_TYPE_F64;
        arg_view_type[14] = AM_VIEW_TYPE_F64;
        arg_view_type[15] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        int in_stride_5 = arg_stride[4];
        uint8_t *in_ptr_5 = &arg_data[4][0];
        int in_stride_6 = arg_stride[5];
        uint8_t *in_ptr_6 = &arg_data[5][0];
        int in_stride_7 = arg_stride[6];
        uint8_t *in_ptr_7 = &arg_data[6][0];
        int in_stride_8 = arg_stride[7];
        uint8_t *in_ptr_8 = &arg_data[7][0];
        int in_stride_9 = arg_stride[8];
        uint8_t *in_ptr_9 = &arg_data[8][0];
        int in_stride_10 = arg_stride[9];
        uint8_t *in_ptr_10 = &arg_data[9][0];
        int in_stride_11 = arg_stride[10];
        uint8_t *in_ptr_11 = &arg_data[10][0];
        int in_stride_12 = arg_stride[11];
        uint8_t *in_ptr_12 = &arg_data[11][0];
        int in_stride_13 = arg_stride[12];
        uint8_t *in_ptr_13 = &arg_data[12][0];
        int in_stride_14 = arg_stride[13];
        uint8_t *in_ptr_14 = &arg_data[13][0];
        int in_stride_15 = arg_stride[14];
        uint8_t *in_ptr_15 = &arg_data[14][0];
        int in_stride_16 = arg_stride[15];
        uint8_t *in_ptr_16 = &arg_data[15][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = glm::dmat4(*((double*)in_ptr_1), *((double*)in_ptr_2), *((double*)in_ptr_3), *((double*)in_ptr_4), *((double*)in_ptr_5), *((double*)in_ptr_6), *((double*)in_ptr_7), *((double*)in_ptr_8), *((double*)in_ptr_9), *((double*)in_ptr_10), *((double*)in_ptr_11), *((double*)in_ptr_12), *((double*)in_ptr_13), *((double*)in_ptr_14), *((double*)in_ptr_15), *((double*)in_ptr_16));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            in_ptr_5 += in_stride_5;
            in_ptr_6 += in_stride_6;
            in_ptr_7 += in_stride_7;
            in_ptr_8 += in_stride_8;
            in_ptr_9 += in_stride_9;
            in_ptr_10 += in_stride_10;
            in_ptr_11 += in_stride_11;
            in_ptr_12 += in_stride_12;
            in_ptr_13 += in_stride_13;
            in_ptr_14 += in_stride_14;
            in_ptr_15 += in_stride_15;
            in_ptr_16 += in_stride_16;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 4  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view) && arg_components[2] == 4 && ((arg_type[2] == MT_am_buffer_view && arg_view_type[2] == AM_VIEW_TYPE_F64) || arg_type[2] != MT_am_buffer_view) && arg_components[3] == 4 && ((arg_type[3] == MT_am_buffer_view && arg_view_type[3] == AM_VIEW_TYPE_F64) || arg_type[3] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        arg_view_type[2] = AM_VIEW_TYPE_F64;
        arg_view_type[3] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat4", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        int in_stride_3 = arg_stride[2];
        uint8_t *in_ptr_3 = &arg_data[2][0];
        int in_stride_4 = arg_stride[3];
        uint8_t *in_ptr_4 = &arg_data[3][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = glm::dmat4(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2), *((glm::dvec4*)in_ptr_3), *((glm::dvec4*)in_ptr_4));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            in_ptr_3 += in_stride_3;
            in_ptr_4 += in_stride_4;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat4");
}

static int am_mathv_mat4(lua_State *L) {
    return mat4_impl(L, NULL);
}

static int am_mathv_mat4_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat4_impl(L, view);
}

static int mat_mul_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.mat_mul");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.mat_mul", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = MAT_MUL(*((glm::vec4*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = MAT_MUL(*((float*)in_ptr_1), *((glm::mat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = MAT_MUL(*((glm::mat4*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = MAT_MUL(*((glm::vec3*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = MAT_MUL(*((float*)in_ptr_1), *((glm::mat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = MAT_MUL(*((glm::mat3*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = MAT_MUL(*((glm::dvec4*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 16 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = MAT_MUL(*((double*)in_ptr_1), *((glm::dmat4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = MAT_MUL(*((glm::dmat4*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = MAT_MUL(*((glm::dvec3*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 9 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = MAT_MUL(*((double*)in_ptr_1), *((glm::dmat3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.mat_mul", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = MAT_MUL(*((glm::dmat3*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.mat_mul");
}

static int am_mathv_mat_mul(lua_State *L) {
    return mat_mul_impl(L, NULL);
}

static int am_mathv_mat_mul_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return mat_mul_impl(L, view);
}

static int cross_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.cross");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.cross", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.cross", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::cross(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.cross", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::cross(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.cross");
}

static int am_mathv_cross(lua_State *L) {
    return cross_impl(L, NULL);
}

static int am_mathv_cross_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return cross_impl(L, view);
}

static int distance_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.distance");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.distance", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::distance(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::distance(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::distance(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::distance(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::distance(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.distance", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::distance(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.distance");
}

static int am_mathv_distance(lua_State *L) {
    return distance_impl(L, NULL);
}

static int am_mathv_distance_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return distance_impl(L, view);
}

static int dot_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.dot");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.dot", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::dot(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::dot(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::dot(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::dot(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::dot(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.dot", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::dot(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.dot");
}

static int am_mathv_dot(lua_State *L) {
    return dot_impl(L, NULL);
}

static int am_mathv_dot_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return dot_impl(L, view);
}

static int inverse_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.inverse");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.inverse", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 1  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.inverse", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat3*)output_data) = glm::inverse(*((glm::mat3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.inverse", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::mat4*)output_data) = glm::inverse(*((glm::mat4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 9 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.inverse", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 9;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat3*)output_data) = glm::inverse(*((glm::dmat3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 16 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.inverse", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 16;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dmat4*)output_data) = glm::inverse(*((glm::dmat4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.inverse");
}

static int am_mathv_inverse(lua_State *L) {
    return inverse_impl(L, NULL);
}

static int am_mathv_inverse_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return inverse_impl(L, view);
}

static int length_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.length");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.length", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::length(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::length(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::length(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::length(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::length(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.length", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::length(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.length");
}

static int am_mathv_length(lua_State *L) {
    return length_impl(L, NULL);
}

static int am_mathv_length_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return length_impl(L, view);
}

static int normalize_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.normalize");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.normalize", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec2*)output_data) = glm::normalize(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec3*)output_data) = glm::normalize(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::vec4*)output_data) = glm::normalize(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 2;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec2*)output_data) = glm::normalize(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 3;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec3*)output_data) = glm::normalize(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.normalize", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 4;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((glm::dvec4*)output_data) = glm::normalize(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.normalize");
}

static int am_mathv_normalize(lua_State *L) {
    return normalize_impl(L, NULL);
}

static int am_mathv_normalize_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return normalize_impl(L, view);
}

static int perlin_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 2) return luaL_error(L, "too many arguments for mathv.perlin");        uint8_t arg_singleton_scratch[2][16*8];
    uint8_t *arg_singleton_bufs[2];
    for (unsigned int i = 0; i < 2; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[2];
    unsigned int arg_stride[2];
    unsigned int arg_count[2];
    int arg_type[2];
    am_buffer_view_type arg_view_type[2];
    unsigned int arg_components[2];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.perlin", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = PERLIN1_F32(*((float*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = PERLIN2_F32(*((float*)in_ptr_1), *((float*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec2*)in_ptr_1), *((glm::vec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec3*)in_ptr_1), *((glm::vec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F32) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        arg_view_type[1] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::perlin(*((glm::vec4*)in_ptr_1), *((glm::vec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = PERLIN1_F64(*((double*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 1 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = PERLIN2_F64(*((double*)in_ptr_1), *((double*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 2 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec2*)in_ptr_1), *((glm::dvec2*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 3 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec3*)in_ptr_1), *((glm::dvec3*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 2  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view) && arg_components[1] == 4 && ((arg_type[1] == MT_am_buffer_view && arg_view_type[1] == AM_VIEW_TYPE_F64) || arg_type[1] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        arg_view_type[1] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.perlin", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        int in_stride_2 = arg_stride[1];
        uint8_t *in_ptr_2 = &arg_data[1][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = glm::perlin(*((glm::dvec4*)in_ptr_1), *((glm::dvec4*)in_ptr_2));
            in_ptr_1 += in_stride_1;
            in_ptr_2 += in_stride_2;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.perlin");
}

static int am_mathv_perlin(lua_State *L) {
    return perlin_impl(L, NULL);
}

static int am_mathv_perlin_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return perlin_impl(L, view);
}

static int simplex_impl(lua_State *L, am_buffer_view *target) {
    int nargs = lua_gettop(L) - (target == NULL ? 0 : 1);
    if (nargs > 1) return luaL_error(L, "too many arguments for mathv.simplex");        uint8_t arg_singleton_scratch[1][16*8];
    uint8_t *arg_singleton_bufs[1];
    for (unsigned int i = 0; i < 1; i++) {
        arg_singleton_bufs[i] = &arg_singleton_scratch[i][0];
    }
    uint8_t *arg_data[1];
    unsigned int arg_stride[1];
    unsigned int arg_count[1];
    int arg_type[1];
    am_buffer_view_type arg_view_type[1];
    unsigned int arg_components[1];
    am_buffer_view_type output_view_type;
    unsigned int output_count;
    unsigned int output_components;
    unsigned int output_stride;
    uint8_t *output_data;
    bool output_is_dense;
    element_wise_setup(L, "mathv.simplex", nargs, 
        arg_type, arg_view_type, arg_count, arg_data, arg_stride, arg_components, arg_singleton_bufs, 
        &output_count);
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = SIMPLEX1_F32(*((float*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::simplex(*((glm::vec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::simplex(*((glm::vec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F32) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F32;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F32;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((float*)output_data) = glm::simplex(*((glm::vec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 1 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = SIMPLEX1_F64(*((double*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 2 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = SIMPLEX2_F64(*((glm::dvec2*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 3 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = SIMPLEX3_F64(*((glm::dvec3*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    if (nargs == 1  && arg_components[0] == 4 && ((arg_type[0] == MT_am_buffer_view && arg_view_type[0] == AM_VIEW_TYPE_F64) || arg_type[0] != MT_am_buffer_view)) {
        arg_view_type[0] = AM_VIEW_TYPE_F64;
        setup_non_view_args(L, "mathv.simplex", nargs, arg_type, arg_view_type, arg_components, arg_singleton_bufs, arg_data);
        output_view_type = AM_VIEW_TYPE_F64;
        output_components = 1;
        create_output_view(L, target, output_view_type, &output_count, output_components, &output_stride, &output_data, &output_is_dense);
        int in_stride_1 = arg_stride[0];
        uint8_t *in_ptr_1 = &arg_data[0][0];
        for (unsigned int i = 0; i < output_count; ++i) {
            *((double*)output_data) = SIMPLEX4_F64(*((glm::dvec4*)in_ptr_1));
            in_ptr_1 += in_stride_1;
            output_data += output_stride;
        }
        return 1;
    }
    return luaL_error(L, "invalid argument types for function mathv.simplex");
}

static int am_mathv_simplex(lua_State *L) {
    return simplex_impl(L, NULL);
}

static int am_mathv_simplex_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return simplex_impl(L, view);
}

static int am_mathv_filter(lua_State *L) {
    return filter_impl(L, NULL);
}

static int am_mathv_filter_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return filter_impl(L, view);
}

static int am_mathv_eq(lua_State *L) {
    return eq_impl(L, NULL);
}

static int am_mathv_eq_into(lua_State *L) {
    am_check_nargs(L, 1);
    am_buffer_view *view = am_check_buffer_view(L, 1);
    lua_pushvalue(L, 1); // return view
    lua_remove(L, 1);
    return eq_impl(L, view);
}

void am_register_mathv_view_methods(lua_State *L) {
    lua_pushcclosure(L, am_mathv_add, 0);
    lua_setfield(L, -2, "__add");
    lua_pushcclosure(L, am_mathv_sub, 0);
    lua_setfield(L, -2, "__sub");
    lua_pushcclosure(L, am_mathv_mul, 0);
    lua_setfield(L, -2, "__mul");
    lua_pushcclosure(L, am_mathv_div, 0);
    lua_setfield(L, -2, "__div");
    lua_pushcclosure(L, am_mathv_mod, 0);
    lua_setfield(L, -2, "__mod");
    lua_pushcclosure(L, am_mathv_pow, 0);
    lua_setfield(L, -2, "__pow");
    lua_pushcclosure(L, am_mathv_unm, 0);
    lua_setfield(L, -2, "__unm");
    lua_pushcclosure(L, am_mathv_add_into, 0);
    lua_setfield(L, -2, "add");
    lua_pushcclosure(L, am_mathv_sub_into, 0);
    lua_setfield(L, -2, "sub");
    lua_pushcclosure(L, am_mathv_vec_mul_into, 0);
    lua_setfield(L, -2, "vec_mul");
    lua_pushcclosure(L, am_mathv_div_into, 0);
    lua_setfield(L, -2, "div");
    lua_pushcclosure(L, am_mathv_mod_into, 0);
    lua_setfield(L, -2, "mod");
    lua_pushcclosure(L, am_mathv_pow_into, 0);
    lua_setfield(L, -2, "pow");
    lua_pushcclosure(L, am_mathv_unm_into, 0);
    lua_setfield(L, -2, "unm");
    lua_pushcclosure(L, am_mathv_abs_into, 0);
    lua_setfield(L, -2, "abs");
    lua_pushcclosure(L, am_mathv_acos_into, 0);
    lua_setfield(L, -2, "acos");
    lua_pushcclosure(L, am_mathv_asin_into, 0);
    lua_setfield(L, -2, "asin");
    lua_pushcclosure(L, am_mathv_atan_into, 0);
    lua_setfield(L, -2, "atan");
    lua_pushcclosure(L, am_mathv_atan2_into, 0);
    lua_setfield(L, -2, "atan2");
    lua_pushcclosure(L, am_mathv_ceil_into, 0);
    lua_setfield(L, -2, "ceil");
    lua_pushcclosure(L, am_mathv_clamp_into, 0);
    lua_setfield(L, -2, "clamp");
    lua_pushcclosure(L, am_mathv_cos_into, 0);
    lua_setfield(L, -2, "cos");
    lua_pushcclosure(L, am_mathv_floor_into, 0);
    lua_setfield(L, -2, "floor");
    lua_pushcclosure(L, am_mathv_fract_into, 0);
    lua_setfield(L, -2, "fract");
    lua_pushcclosure(L, am_mathv_log_into, 0);
    lua_setfield(L, -2, "log");
    lua_pushcclosure(L, am_mathv_max_into, 0);
    lua_setfield(L, -2, "max");
    lua_pushcclosure(L, am_mathv_min_into, 0);
    lua_setfield(L, -2, "min");
    lua_pushcclosure(L, am_mathv_mix_into, 0);
    lua_setfield(L, -2, "mix");
    lua_pushcclosure(L, am_mathv_sign_into, 0);
    lua_setfield(L, -2, "sign");
    lua_pushcclosure(L, am_mathv_sin_into, 0);
    lua_setfield(L, -2, "sin");
    lua_pushcclosure(L, am_mathv_tan_into, 0);
    lua_setfield(L, -2, "tan");
    lua_pushcclosure(L, am_mathv_lt_into, 0);
    lua_setfield(L, -2, "lt");
    lua_pushcclosure(L, am_mathv_lte_into, 0);
    lua_setfield(L, -2, "lte");
    lua_pushcclosure(L, am_mathv_gt_into, 0);
    lua_setfield(L, -2, "gt");
    lua_pushcclosure(L, am_mathv_gte_into, 0);
    lua_setfield(L, -2, "gte");
    lua_pushcclosure(L, am_mathv_and__into, 0);
    lua_setfield(L, -2, "and_");
    lua_pushcclosure(L, am_mathv_or__into, 0);
    lua_setfield(L, -2, "or_");
    lua_pushcclosure(L, am_mathv_not__into, 0);
    lua_setfield(L, -2, "not_");
    lua_pushcclosure(L, am_mathv_vec2_into, 0);
    lua_setfield(L, -2, "vec2");
    lua_pushcclosure(L, am_mathv_vec3_into, 0);
    lua_setfield(L, -2, "vec3");
    lua_pushcclosure(L, am_mathv_vec4_into, 0);
    lua_setfield(L, -2, "vec4");
    lua_pushcclosure(L, am_mathv_mat3_into, 0);
    lua_setfield(L, -2, "mat3");
    lua_pushcclosure(L, am_mathv_mat4_into, 0);
    lua_setfield(L, -2, "mat4");
    lua_pushcclosure(L, am_mathv_mat_mul_into, 0);
    lua_setfield(L, -2, "mat_mul");
    lua_pushcclosure(L, am_mathv_cross_into, 0);
    lua_setfield(L, -2, "cross");
    lua_pushcclosure(L, am_mathv_distance_into, 0);
    lua_setfield(L, -2, "distance");
    lua_pushcclosure(L, am_mathv_dot_into, 0);
    lua_setfield(L, -2, "dot");
    lua_pushcclosure(L, am_mathv_inverse_into, 0);
    lua_setfield(L, -2, "inverse");
    lua_pushcclosure(L, am_mathv_length_into, 0);
    lua_setfield(L, -2, "length");
    lua_pushcclosure(L, am_mathv_normalize_into, 0);
    lua_setfield(L, -2, "normalize");
    lua_pushcclosure(L, am_mathv_perlin_into, 0);
    lua_setfield(L, -2, "perlin");
    lua_pushcclosure(L, am_mathv_simplex_into, 0);
    lua_setfield(L, -2, "simplex");
    lua_pushcclosure(L, am_mathv_filter_into, 0);
    lua_setfield(L, -2, "filter");
    lua_pushcclosure(L, am_mathv_eq_into, 0);
    lua_setfield(L, -2, "eq");
}

void am_open_mathv_module(lua_State *L) {
    luaL_Reg vfuncs[] = {
        {"range",    am_mathv_range},
        {"random",   am_mathv_random},
        {"cart",     am_mathv_cart},
        {"mul",      am_mathv_mul},
        {"sum",      am_mathv_sum},
        {"greatest", am_mathv_greatest},
        {"least",    am_mathv_least},
        {"add", am_mathv_add},
        {"sub", am_mathv_sub},
        {"vec_mul", am_mathv_vec_mul},
        {"div", am_mathv_div},
        {"mod", am_mathv_mod},
        {"pow", am_mathv_pow},
        {"unm", am_mathv_unm},
        {"abs", am_mathv_abs},
        {"acos", am_mathv_acos},
        {"asin", am_mathv_asin},
        {"atan", am_mathv_atan},
        {"atan2", am_mathv_atan2},
        {"ceil", am_mathv_ceil},
        {"clamp", am_mathv_clamp},
        {"cos", am_mathv_cos},
        {"floor", am_mathv_floor},
        {"fract", am_mathv_fract},
        {"log", am_mathv_log},
        {"max", am_mathv_max},
        {"min", am_mathv_min},
        {"mix", am_mathv_mix},
        {"sign", am_mathv_sign},
        {"sin", am_mathv_sin},
        {"tan", am_mathv_tan},
        {"lt", am_mathv_lt},
        {"lte", am_mathv_lte},
        {"gt", am_mathv_gt},
        {"gte", am_mathv_gte},
        {"and_", am_mathv_and_},
        {"or_", am_mathv_or_},
        {"not_", am_mathv_not_},
        {"vec2", am_mathv_vec2},
        {"vec3", am_mathv_vec3},
        {"vec4", am_mathv_vec4},
        {"mat3", am_mathv_mat3},
        {"mat4", am_mathv_mat4},
        {"mat_mul", am_mathv_mat_mul},
        {"cross", am_mathv_cross},
        {"distance", am_mathv_distance},
        {"dot", am_mathv_dot},
        {"inverse", am_mathv_inverse},
        {"length", am_mathv_length},
        {"normalize", am_mathv_normalize},
        {"perlin", am_mathv_perlin},
        {"simplex", am_mathv_simplex},
        {"filter", am_mathv_filter},
        {"eq", am_mathv_eq},
        {NULL, NULL}
    };
    am_open_module(L, "mathv", vfuncs);
}
